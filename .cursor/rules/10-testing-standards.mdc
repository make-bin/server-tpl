---
description:
globs:
alwaysApply: false
---

# 8. æµ‹è¯•è§„èŒƒ

## 8.1 æ¦‚è¿°

æœ¬è§„èŒƒå®šä¹‰äº†Go HTTP Serveré¡¹ç›®çš„æµ‹è¯•æ ‡å‡†ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æµ‹è¯•è¦†ç›–ç‡è¦æ±‚ã€æµ‹è¯•å·¥å…·å’Œæœ€ä½³å®è·µã€‚

## 8.2 æµ‹è¯•æ¶æ„

### 8.2.1 æµ‹è¯•é‡‘å­—å¡”
```
æµ‹è¯•é‡‘å­—å¡”ï¼ˆä»åº•åˆ°é¡¶ï¼‰ï¼š
1. å•å…ƒæµ‹è¯• - æµ‹è¯•å•ä¸ªå‡½æ•°/æ–¹æ³•
2. é›†æˆæµ‹è¯• - æµ‹è¯•ç»„ä»¶é—´äº¤äº’
3. ç«¯åˆ°ç«¯æµ‹è¯• - æµ‹è¯•å®Œæ•´ä¸šåŠ¡æµç¨‹
4. æ€§èƒ½æµ‹è¯• - æµ‹è¯•ç³»ç»Ÿæ€§èƒ½
```

### 8.2.2 æµ‹è¯•åˆ†ç±»
- **å•å…ƒæµ‹è¯•**: æµ‹è¯•æœ€å°å¯æµ‹è¯•å•å…ƒ
- **é›†æˆæµ‹è¯•**: æµ‹è¯•å¤šä¸ªç»„ä»¶åä½œ
- **APIæµ‹è¯•**: æµ‹è¯•HTTPæ¥å£
- **æ•°æ®åº“æµ‹è¯•**: æµ‹è¯•æ•°æ®è®¿é—®å±‚
- **æ€§èƒ½æµ‹è¯•**: æµ‹è¯•ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡

## 8.3 å•å…ƒæµ‹è¯•è§„èŒƒ

### 8.3.1 æµ‹è¯•æ–‡ä»¶å‘½å
```go
// æµ‹è¯•æ–‡ä»¶å‘½åè§„èŒƒ
// åŸæ–‡ä»¶: user_service.go
// æµ‹è¯•æ–‡ä»¶: user_service_test.go

// æµ‹è¯•å‡½æ•°å‘½åè§„èŒƒ
func TestUserService_CreateUser(t *testing.T) { }
func TestUserService_CreateUser_WithInvalidData(t *testing.T) { }
func TestUserService_CreateUser_WithDuplicateEmail(t *testing.T) { }
```

### 8.3.2 æµ‹è¯•ç»“æ„
```go
package service

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/suite"
    
    "github.com/make-bin/server-tpl/pkg/model"
    "github.com/make-bin/server-tpl/pkg/repository"
)

// UserServiceTestSuite ç”¨æˆ·æœåŠ¡æµ‹è¯•å¥—ä»¶
type UserServiceTestSuite struct {
    suite.Suite
    userRepo *repository.MockUserRepository
    userSvc  *UserService
    ctx      context.Context
}

// SetupSuite æµ‹è¯•å¥—ä»¶åˆå§‹åŒ–
func (suite *UserServiceTestSuite) SetupSuite() {
    suite.ctx = context.Background()
}

// SetupTest æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹åˆå§‹åŒ–
func (suite *UserServiceTestSuite) SetupTest() {
    suite.userRepo = repository.NewMockUserRepository(suite.T())
    suite.userSvc = NewUserService(suite.userRepo)
}

// TearDownTest æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹æ¸…ç†
func (suite *UserServiceTestSuite) TearDownTest() {
    suite.userRepo.AssertExpectations(suite.T())
}

// TestCreateUser_Success æµ‹è¯•æˆåŠŸåˆ›å»ºç”¨æˆ·
func (suite *UserServiceTestSuite) TestCreateUser_Success() {
    // Arrange
    user := &model.User{
        ID:       "user-123",
        Email:    "test@example.com",
        Name:     "Test User",
        Password: "password123",
    }
    
    suite.userRepo.On("Create", suite.ctx, mock.AnythingOfType("*model.User")).
        Return(user, nil)
    
    // Act
    result, err := suite.userSvc.CreateUser(suite.ctx, user)
    
    // Assert
    suite.NoError(err)
    suite.NotNil(result)
    suite.Equal(user.ID, result.ID)
    suite.Equal(user.Email, result.Email)
    suite.Equal(user.Name, result.Name)
    suite.NotEqual(user.Password, result.Password) // å¯†ç åº”è¯¥è¢«åŠ å¯†
}

// TestCreateUser_WithDuplicateEmail æµ‹è¯•åˆ›å»ºé‡å¤é‚®ç®±ç”¨æˆ·
func (suite *UserServiceTestSuite) TestCreateUser_WithDuplicateEmail() {
    // Arrange
    user := &model.User{
        Email:    "existing@example.com",
        Name:     "Test User",
        Password: "password123",
    }
    
    suite.userRepo.On("Create", suite.ctx, mock.AnythingOfType("*model.User")).
        Return(nil, repository.ErrDuplicateEmail)
    
    // Act
    result, err := suite.userSvc.CreateUser(suite.ctx, user)
    
    // Assert
    suite.Error(err)
    suite.Nil(result)
    suite.Equal(repository.ErrDuplicateEmail, err)
}

// TestGetUser_Success æµ‹è¯•æˆåŠŸè·å–ç”¨æˆ·
func (suite *UserServiceTestSuite) TestGetUser_Success() {
    // Arrange
    userID := "user-123"
    expectedUser := &model.User{
        ID:    userID,
        Email: "test@example.com",
        Name:  "Test User",
    }
    
    suite.userRepo.On("GetByID", suite.ctx, userID).
        Return(expectedUser, nil)
    
    // Act
    result, err := suite.userSvc.GetUser(suite.ctx, userID)
    
    // Assert
    suite.NoError(err)
    suite.NotNil(result)
    suite.Equal(expectedUser.ID, result.ID)
    suite.Equal(expectedUser.Email, result.Email)
    suite.Equal(expectedUser.Name, result.Name)
}

// TestGetUser_NotFound æµ‹è¯•è·å–ä¸å­˜åœ¨çš„ç”¨æˆ·
func (suite *UserServiceTestSuite) TestGetUser_NotFound() {
    // Arrange
    userID := "non-existent"
    
    suite.userRepo.On("GetByID", suite.ctx, userID).
        Return(nil, repository.ErrUserNotFound)
    
    // Act
    result, err := suite.userSvc.GetUser(suite.ctx, userID)
    
    // Assert
    suite.Error(err)
    suite.Nil(result)
    suite.Equal(repository.ErrUserNotFound, err)
}

// è¿è¡Œæµ‹è¯•å¥—ä»¶
func TestUserServiceTestSuite(t *testing.T) {
    suite.Run(t, new(UserServiceTestSuite))
}
```

### 8.3.3 æµ‹è¯•å·¥å…·å’Œæ–­è¨€
```go
package testutils

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"
)

// TestUtils æµ‹è¯•å·¥å…·
type TestUtils struct {
    suite.Suite
}

// AssertUserEqual æ–­è¨€ç”¨æˆ·ç›¸ç­‰
func (tu *TestUtils) AssertUserEqual(expected, actual *model.User) {
    tu.Equal(expected.ID, actual.ID)
    tu.Equal(expected.Email, actual.Email)
    tu.Equal(expected.Name, actual.Name)
    tu.Equal(expected.Status, actual.Status)
    tu.WithinDuration(expected.CreatedAt, actual.CreatedAt, time.Second)
    tu.WithinDuration(expected.UpdatedAt, actual.UpdatedAt, time.Second)
}

// CreateTestUser åˆ›å»ºæµ‹è¯•ç”¨æˆ·
func (tu *TestUtils) CreateTestUser() *model.User {
    return &model.User{
        ID:       "test-user-" + time.Now().Format("20060102150405"),
        Email:    "test@example.com",
        Name:     "Test User",
        Password: "password123",
        Status:   model.UserStatusActive,
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
}

// CreateTestContext åˆ›å»ºæµ‹è¯•ä¸Šä¸‹æ–‡
func (tu *TestUtils) CreateTestContext() context.Context {
    return context.WithValue(context.Background(), "test", true)
}

// AssertErrorCode æ–­è¨€é”™è¯¯ç 
func (tu *TestUtils) AssertErrorCode(err error, expectedCode int) {
    if businessErr, ok := err.(*bcode.Error); ok {
        tu.Equal(expectedCode, businessErr.Code)
    } else {
        tu.Fail("é”™è¯¯ä¸æ˜¯ä¸šåŠ¡é”™è¯¯ç±»å‹")
    }
}

// AssertHTTPStatus æ–­è¨€HTTPçŠ¶æ€ç 
func (tu *TestUtils) AssertHTTPStatus(t *testing.T, recorder *httptest.ResponseRecorder, expectedStatus int) {
    require.Equal(t, expectedStatus, recorder.Code)
}

// AssertJSONResponse æ–­è¨€JSONå“åº”
func (tu *TestUtils) AssertJSONResponse(t *testing.T, recorder *httptest.ResponseRecorder, expected interface{}) {
    var response map[string]interface{}
    err := json.Unmarshal(recorder.Body.Bytes(), &response)
    require.NoError(t, err)
    
    expectedBytes, err := json.Marshal(expected)
    require.NoError(t, err)
    
    var expectedMap map[string]interface{}
    err = json.Unmarshal(expectedBytes, &expectedMap)
    require.NoError(t, err)
    
    assert.Equal(t, expectedMap, response)
}
```

## 8.4 é›†æˆæµ‹è¯•è§„èŒƒ

### 8.4.1 æ•°æ®åº“é›†æˆæµ‹è¯•
```go
package integration

import (
    "context"
    "database/sql"
    "testing"
    "time"
    
    "github.com/stretchr/testify/suite"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    
    "github.com/make-bin/server-tpl/pkg/model"
    "github.com/make-bin/server-tpl/pkg/repository"
    "github.com/make-bin/server-tpl/pkg/service"
)

// DatabaseTestSuite æ•°æ®åº“æµ‹è¯•å¥—ä»¶
type DatabaseTestSuite struct {
    suite.Suite
    db       *gorm.DB
    userRepo repository.UserRepository
    userSvc  *service.UserService
    ctx      context.Context
}

// SetupSuite æµ‹è¯•å¥—ä»¶åˆå§‹åŒ–
func (suite *DatabaseTestSuite) SetupSuite() {
    // è¿æ¥æµ‹è¯•æ•°æ®åº“
    dsn := "host=localhost user=test password=test dbname=test_db port=5432 sslmode=disable"
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    suite.Require().NoError(err)
    
    suite.db = db
    suite.ctx = context.Background()
    
    // è¿è¡Œæ•°æ®åº“è¿ç§»
    err = suite.db.AutoMigrate(&model.User{})
    suite.Require().NoError(err)
}

// SetupTest æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹åˆå§‹åŒ–
func (suite *DatabaseTestSuite) SetupTest() {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    suite.db.Exec("DELETE FROM users")
    
    // åˆå§‹åŒ–ä¾èµ–
    suite.userRepo = repository.NewUserRepository(suite.db)
    suite.userSvc = service.NewUserService(suite.userRepo)
}

// TearDownSuite æµ‹è¯•å¥—ä»¶æ¸…ç†
func (suite *DatabaseTestSuite) TearDownSuite() {
    // æ¸…ç†æµ‹è¯•æ•°æ®åº“
    sqlDB, err := suite.db.DB()
    suite.Require().NoError(err)
    sqlDB.Close()
}

// TestUserService_CreateAndGetUser æµ‹è¯•åˆ›å»ºå’Œè·å–ç”¨æˆ·
func (suite *DatabaseTestSuite) TestUserService_CreateAndGetUser() {
    // Arrange
    user := &model.User{
        Email:    "integration@example.com",
        Name:     "Integration Test User",
        Password: "password123",
        Status:   model.UserStatusActive,
    }
    
    // Act - åˆ›å»ºç”¨æˆ·
    createdUser, err := suite.userSvc.CreateUser(suite.ctx, user)
    suite.Require().NoError(err)
    suite.Require().NotNil(createdUser)
    suite.Require().NotEmpty(createdUser.ID)
    
    // Act - è·å–ç”¨æˆ·
    retrievedUser, err := suite.userSvc.GetUser(suite.ctx, createdUser.ID)
    
    // Assert
    suite.NoError(err)
    suite.NotNil(retrievedUser)
    suite.Equal(createdUser.ID, retrievedUser.ID)
    suite.Equal(createdUser.Email, retrievedUser.Email)
    suite.Equal(createdUser.Name, retrievedUser.Name)
    suite.NotEqual(user.Password, retrievedUser.Password) // å¯†ç åº”è¯¥è¢«åŠ å¯†
}

// TestUserService_UpdateUser æµ‹è¯•æ›´æ–°ç”¨æˆ·
func (suite *DatabaseTestSuite) TestUserService_UpdateUser() {
    // Arrange
    user := &model.User{
        Email:    "update@example.com",
        Name:     "Update Test User",
        Password: "password123",
        Status:   model.UserStatusActive,
    }
    
    createdUser, err := suite.userSvc.CreateUser(suite.ctx, user)
    suite.Require().NoError(err)
    
    // Act
    updateData := &model.User{
        Name:   "Updated Name",
        Status: model.UserStatusInactive,
    }
    
    updatedUser, err := suite.userSvc.UpdateUser(suite.ctx, createdUser.ID, updateData)
    
    // Assert
    suite.NoError(err)
    suite.NotNil(updatedUser)
    suite.Equal(createdUser.ID, updatedUser.ID)
    suite.Equal(createdUser.Email, updatedUser.Email) // é‚®ç®±ä¸åº”è¯¥è¢«æ›´æ–°
    suite.Equal(updateData.Name, updatedUser.Name)
    suite.Equal(updateData.Status, updatedUser.Status)
}

// TestUserService_DeleteUser æµ‹è¯•åˆ é™¤ç”¨æˆ·
func (suite *DatabaseTestSuite) TestUserService_DeleteUser() {
    // Arrange
    user := &model.User{
        Email:    "delete@example.com",
        Name:     "Delete Test User",
        Password: "password123",
        Status:   model.UserStatusActive,
    }
    
    createdUser, err := suite.userSvc.CreateUser(suite.ctx, user)
    suite.Require().NoError(err)
    
    // Act
    err = suite.userSvc.DeleteUser(suite.ctx, createdUser.ID)
    
    // Assert
    suite.NoError(err)
    
    // éªŒè¯ç”¨æˆ·å·²è¢«åˆ é™¤
    _, err = suite.userSvc.GetUser(suite.ctx, createdUser.ID)
    suite.Error(err)
    suite.Equal(repository.ErrUserNotFound, err)
}

// è¿è¡Œæµ‹è¯•å¥—ä»¶
func TestDatabaseTestSuite(t *testing.T) {
    suite.Run(t, new(DatabaseTestSuite))
}
```

### 8.4.2 APIé›†æˆæµ‹è¯•
```go
package api

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/suite"
    
    "github.com/make-bin/server-tpl/pkg/api"
    "github.com/make-bin/server-tpl/pkg/model"
    "github.com/make-bin/server-tpl/pkg/service"
)

// APITestSuite APIæµ‹è¯•å¥—ä»¶
type APITestSuite struct {
    suite.Suite
    router *gin.Engine
    userSvc *service.UserService
}

// SetupSuite æµ‹è¯•å¥—ä»¶åˆå§‹åŒ–
func (suite *APITestSuite) SetupSuite() {
    // è®¾ç½®Ginä¸ºæµ‹è¯•æ¨¡å¼
    gin.SetMode(gin.TestMode)
    
    // åˆå§‹åŒ–è·¯ç”±
    suite.router = gin.New()
    suite.userSvc = service.NewUserService(nil) // ä½¿ç”¨Mock
    
    // æ³¨å†Œè·¯ç”±
    userController := api.NewUserController(suite.userSvc)
    api.RegisterRoutes(suite.router, userController)
}

// TestCreateUser_Success æµ‹è¯•æˆåŠŸåˆ›å»ºç”¨æˆ·API
func (suite *APITestSuite) TestCreateUser_Success() {
    // Arrange
    requestBody := map[string]interface{}{
        "email":    "api@example.com",
        "name":     "API Test User",
        "password": "password123",
    }
    
    requestBytes, err := json.Marshal(requestBody)
    suite.Require().NoError(err)
    
    req, err := http.NewRequest("POST", "/api/v1/users", bytes.NewBuffer(requestBytes))
    suite.Require().NoError(err)
    req.Header.Set("Content-Type", "application/json")
    
    recorder := httptest.NewRecorder()
    
    // Act
    suite.router.ServeHTTP(recorder, req)
    
    // Assert
    suite.Equal(http.StatusCreated, recorder.Code)
    
    var response map[string]interface{}
    err = json.Unmarshal(recorder.Body.Bytes(), &response)
    suite.NoError(err)
    
    suite.NotEmpty(response["id"])
    suite.Equal(requestBody["email"], response["email"])
    suite.Equal(requestBody["name"], response["name"])
    suite.NotEqual(requestBody["password"], response["password"]) // å¯†ç ä¸åº”è¯¥è¿”å›
}

// TestCreateUser_InvalidData æµ‹è¯•åˆ›å»ºç”¨æˆ·API - æ— æ•ˆæ•°æ®
func (suite *APITestSuite) TestCreateUser_InvalidData() {
    // Arrange
    requestBody := map[string]interface{}{
        "email": "invalid-email", // æ— æ•ˆé‚®ç®±
        "name":  "Test User",
    }
    
    requestBytes, err := json.Marshal(requestBody)
    suite.Require().NoError(err)
    
    req, err := http.NewRequest("POST", "/api/v1/users", bytes.NewBuffer(requestBytes))
    suite.Require().NoError(err)
    req.Header.Set("Content-Type", "application/json")
    
    recorder := httptest.NewRecorder()
    
    // Act
    suite.router.ServeHTTP(recorder, req)
    
    // Assert
    suite.Equal(http.StatusBadRequest, recorder.Code)
    
    var response map[string]interface{}
    err = json.Unmarshal(recorder.Body.Bytes(), &response)
    suite.NoError(err)
    
    suite.Equal("validation_error", response["error"])
}

// TestGetUser_Success æµ‹è¯•æˆåŠŸè·å–ç”¨æˆ·API
func (suite *APITestSuite) TestGetUser_Success() {
    // Arrange
    userID := "test-user-123"
    req, err := http.NewRequest("GET", "/api/v1/users/"+userID, nil)
    suite.Require().NoError(err)
    
    recorder := httptest.NewRecorder()
    
    // Act
    suite.router.ServeHTTP(recorder, req)
    
    // Assert
    suite.Equal(http.StatusOK, recorder.Code)
    
    var response map[string]interface{}
    err = json.Unmarshal(recorder.Body.Bytes(), &response)
    suite.NoError(err)
    
    suite.Equal(userID, response["id"])
}

// TestGetUser_NotFound æµ‹è¯•è·å–ç”¨æˆ·API - ç”¨æˆ·ä¸å­˜åœ¨
func (suite *APITestSuite) TestGetUser_NotFound() {
    // Arrange
    userID := "non-existent-user"
    req, err := http.NewRequest("GET", "/api/v1/users/"+userID, nil)
    suite.Require().NoError(err)
    
    recorder := httptest.NewRecorder()
    
    // Act
    suite.router.ServeHTTP(recorder, req)
    
    // Assert
    suite.Equal(http.StatusNotFound, recorder.Code)
    
    var response map[string]interface{}
    err = json.Unmarshal(recorder.Body.Bytes(), &response)
    suite.NoError(err)
    
    suite.Equal("user_not_found", response["error"])
}

// è¿è¡Œæµ‹è¯•å¥—ä»¶
func TestAPITestSuite(t *testing.T) {
    suite.Run(t, new(APITestSuite))
}
```

## 8.5 æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

### 8.5.1 è¦†ç›–ç‡ç›®æ ‡
```go
// è¦†ç›–ç‡è¦æ±‚
// å•å…ƒæµ‹è¯•è¦†ç›–ç‡: >= 80%
// é›†æˆæµ‹è¯•è¦†ç›–ç‡: >= 70%
// æ€»ä½“æµ‹è¯•è¦†ç›–ç‡: >= 75%

// ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
func TestMain(m *testing.M) {
    // è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
    result := m.Run()
    
    // æ£€æŸ¥è¦†ç›–ç‡
    if testing.CoverMode() != "" {
        coverage := testing.Coverage()
        if coverage < 0.75 {
            log.Fatalf("æµ‹è¯•è¦†ç›–ç‡ä¸è¶³: %.2f%%, è¦æ±‚ >= 75%%", coverage*100)
        }
    }
    
    os.Exit(result)
}
```

### 8.5.2 è¦†ç›–ç‡æ£€æŸ¥è„šæœ¬
```bash
#!/bin/bash
# scripts/test-coverage.sh

set -e

echo "è¿è¡Œå•å…ƒæµ‹è¯•..."
go test -v -race -coverprofile=coverage.out ./...

echo "ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š..."
go tool cover -func=coverage.out

echo "ç”ŸæˆHTMLè¦†ç›–ç‡æŠ¥å‘Š..."
go tool cover -html=coverage.out -o coverage.html

echo "æ£€æŸ¥è¦†ç›–ç‡..."
COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')

if (( $(echo "$COVERAGE < 75" | bc -l) )); then
    echo "âŒ æµ‹è¯•è¦†ç›–ç‡ä¸è¶³: ${COVERAGE}%, è¦æ±‚ >= 75%"
    exit 1
else
    echo "âœ… æµ‹è¯•è¦†ç›–ç‡è¾¾æ ‡: ${COVERAGE}%"
fi

echo "æ¸…ç†è¦†ç›–ç‡æ–‡ä»¶..."
rm -f coverage.out coverage.html
```

## 8.6 æµ‹è¯•å·¥å…·å’Œæ¡†æ¶

### 8.6.1 æµ‹è¯•ä¾èµ–ç®¡ç†
```go
// go.mod æµ‹è¯•ä¾èµ–
require (
    github.com/stretchr/testify v1.8.4
    github.com/golang/mock v1.6.0
    gopkg.in/go-playground/assert.v1 v1.2.1
)

// ç”ŸæˆMock
//go:generate mockgen -source=pkg/repository/user_repository.go -destination=pkg/repository/mock_user_repository.go -package=repository
```

### 8.6.2 æµ‹è¯•æ•°æ®ç®¡ç†
```go
package testdata

import (
    "github.com/make-bin/server-tpl/pkg/model"
)

// TestUsers æµ‹è¯•ç”¨æˆ·æ•°æ®
var TestUsers = []*model.User{
    {
        ID:       "user-1",
        Email:    "user1@example.com",
        Name:     "User One",
        Password: "password123",
        Status:   model.UserStatusActive,
    },
    {
        ID:       "user-2",
        Email:    "user2@example.com",
        Name:     "User Two",
        Password: "password456",
        Status:   model.UserStatusInactive,
    },
}

// TestApplications æµ‹è¯•åº”ç”¨æ•°æ®
var TestApplications = []*model.Application{
    {
        ID:          "app-1",
        Name:        "Test App 1",
        Description: "Test application 1",
        Status:      model.AppStatusActive,
    },
    {
        ID:          "app-2",
        Name:        "Test App 2",
        Description: "Test application 2",
        Status:      model.AppStatusInactive,
    },
}
```

### 8.6.3 æµ‹è¯•ç¯å¢ƒé…ç½®
```go
package testconfig

import (
    "os"
    "testing"
)

// TestConfig æµ‹è¯•é…ç½®
type TestConfig struct {
    DatabaseURL string
    RedisURL    string
    LogLevel    string
}

// LoadTestConfig åŠ è½½æµ‹è¯•é…ç½®
func LoadTestConfig(t *testing.T) *TestConfig {
    config := &TestConfig{
        DatabaseURL: getEnvOrDefault("TEST_DATABASE_URL", "postgres://test:test@localhost:5432/test_db?sslmode=disable"),
        RedisURL:    getEnvOrDefault("TEST_REDIS_URL", "redis://localhost:6379/1"),
        LogLevel:    getEnvOrDefault("TEST_LOG_LEVEL", "error"),
    }
    
    return config
}

func getEnvOrDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
```

## 8.7 æ€§èƒ½æµ‹è¯•è§„èŒƒ

### 8.7.1 åŸºå‡†æµ‹è¯•
```go
package benchmark

import (
    "context"
    "testing"
    
    "github.com/make-bin/server-tpl/pkg/service"
)

// BenchmarkUserService_CreateUser ç”¨æˆ·åˆ›å»ºåŸºå‡†æµ‹è¯•
func BenchmarkUserService_CreateUser(b *testing.B) {
    userSvc := service.NewUserService(nil)
    ctx := context.Background()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        user := &model.User{
            Email:    "benchmark@example.com",
            Name:     "Benchmark User",
            Password: "password123",
        }
        
        _, err := userSvc.CreateUser(ctx, user)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// BenchmarkUserService_GetUser ç”¨æˆ·è·å–åŸºå‡†æµ‹è¯•
func BenchmarkUserService_GetUser(b *testing.B) {
    userSvc := service.NewUserService(nil)
    ctx := context.Background()
    userID := "benchmark-user"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := userSvc.GetUser(ctx, userID)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

### 8.7.2 è´Ÿè½½æµ‹è¯•
```go
package loadtest

import (
    "net/http"
    "net/http/httptest"
    "testing"
    "time"
    
    "github.com/stretchr/testify/require"
)

// LoadTestConfig è´Ÿè½½æµ‹è¯•é…ç½®
type LoadTestConfig struct {
    Concurrency int
    Duration    time.Duration
    RPS         int // æ¯ç§’è¯·æ±‚æ•°
}

// RunLoadTest è¿è¡Œè´Ÿè½½æµ‹è¯•
func RunLoadTest(t *testing.T, config LoadTestConfig, handler http.HandlerFunc) {
    server := httptest.NewServer(handler)
    defer server.Close()
    
    client := &http.Client{
        Timeout: 30 * time.Second,
    }
    
    // åˆ›å»ºè¯·æ±‚
    req, err := http.NewRequest("GET", server.URL+"/api/v1/users", nil)
    require.NoError(t, err)
    
    // è¿è¡Œè´Ÿè½½æµ‹è¯•
    start := time.Now()
    results := make(chan *http.Response, config.Concurrency)
    errors := make(chan error, config.Concurrency)
    
    // å¯åŠ¨å·¥ä½œåç¨‹
    for i := 0; i < config.Concurrency; i++ {
        go func() {
            for time.Since(start) < config.Duration {
                resp, err := client.Do(req)
                if err != nil {
                    errors <- err
                    continue
                }
                results <- resp
                time.Sleep(time.Second / time.Duration(config.RPS/config.Concurrency))
            }
        }()
    }
    
    // æ”¶é›†ç»“æœ
    var successCount, errorCount int
    timeout := time.After(config.Duration + time.Second)
    
    for {
        select {
        case <-results:
            successCount++
        case <-errors:
            errorCount++
        case <-timeout:
            goto done
        }
    }
    
done:
    t.Logf("è´Ÿè½½æµ‹è¯•ç»“æœ: æˆåŠŸ=%d, é”™è¯¯=%d, æ€»è¯·æ±‚=%d", 
        successCount, errorCount, successCount+errorCount)
}
```

## 8.8 æµ‹è¯•æœ€ä½³å®è·µ

### 8.8.1 æµ‹è¯•ç¼–å†™åŸåˆ™
- **AAAæ¨¡å¼**: Arrangeï¼ˆå‡†å¤‡ï¼‰ã€Actï¼ˆæ‰§è¡Œï¼‰ã€Assertï¼ˆæ–­è¨€ï¼‰
- **å•ä¸€èŒè´£**: æ¯ä¸ªæµ‹è¯•åªæµ‹è¯•ä¸€ä¸ªåŠŸèƒ½ç‚¹
- **ç‹¬ç«‹æ€§**: æµ‹è¯•ä¹‹é—´ä¸åº”è¯¥ç›¸äº’ä¾èµ–
- **å¯è¯»æ€§**: æµ‹è¯•ä»£ç åº”è¯¥æ¸…æ™°æ˜“æ‡‚
- **å¯ç»´æŠ¤æ€§**: æµ‹è¯•ä»£ç åº”è¯¥æ˜“äºç»´æŠ¤å’Œä¿®æ”¹

### 8.8.2 æµ‹è¯•æ•°æ®ç®¡ç†
- **æµ‹è¯•æ•°æ®éš”ç¦»**: æ¯ä¸ªæµ‹è¯•ä½¿ç”¨ç‹¬ç«‹çš„æµ‹è¯•æ•°æ®
- **æ•°æ®æ¸…ç†**: æµ‹è¯•å®Œæˆåæ¸…ç†æµ‹è¯•æ•°æ®
- **æµ‹è¯•æ•°æ®å·¥å‚**: ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºæµ‹è¯•æ•°æ®
- **æµ‹è¯•æ•°æ®æ–‡ä»¶**: å¤æ‚æµ‹è¯•æ•°æ®ä½¿ç”¨å¤–éƒ¨æ–‡ä»¶

### 8.8.3 æµ‹è¯•æ€§èƒ½ä¼˜åŒ–
- **å¹¶è¡Œæµ‹è¯•**: ä½¿ç”¨ `t.Parallel()` å¹¶è¡Œè¿è¡Œæµ‹è¯•
- **æµ‹è¯•ç¼“å­˜**: ç¼“å­˜æµ‹è¯•ç»“æœé¿å…é‡å¤è®¡ç®—
- **èµ„æºå¤ç”¨**: å¤ç”¨æµ‹è¯•èµ„æºå‡å°‘åˆå§‹åŒ–å¼€é”€
- **æµ‹è¯•è¶…æ—¶**: è®¾ç½®åˆç†çš„æµ‹è¯•è¶…æ—¶æ—¶é—´

### 8.8.4 æµ‹è¯•ç¯å¢ƒç®¡ç†
- **ç¯å¢ƒéš”ç¦»**: æµ‹è¯•ç¯å¢ƒä¸ç”Ÿäº§ç¯å¢ƒéš”ç¦»
- **é…ç½®ç®¡ç†**: ä½¿ç”¨ä¸“é—¨çš„æµ‹è¯•é…ç½®
- **ä¾èµ–ç®¡ç†**: ç®¡ç†æµ‹è¯•ä¾èµ–çš„ç‰ˆæœ¬
- **CI/CDé›†æˆ**: åœ¨CI/CDæµç¨‹ä¸­è¿è¡Œæµ‹è¯•

## 8.9 æµ‹è¯•å·¥å…·å’Œè„šæœ¬

### 8.9.1 Makefileæµ‹è¯•å‘½ä»¤
```makefile
# Makefile
.PHONY: test test-unit test-integration test-coverage test-benchmark

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
test:
	go test -v -race ./...

# è¿è¡Œå•å…ƒæµ‹è¯•
test-unit:
	go test -v -race -tags=unit ./...

# è¿è¡Œé›†æˆæµ‹è¯•
test-integration:
	go test -v -race -tags=integration ./...

# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
test-coverage:
	go test -v -race -coverprofile=coverage.out ./...
	go tool cover -func=coverage.out
	go tool cover -html=coverage.out -o coverage.html

# è¿è¡ŒåŸºå‡†æµ‹è¯•
test-benchmark:
	go test -v -bench=. -benchmem ./...

# è¿è¡Œè´Ÿè½½æµ‹è¯•
test-load:
	go test -v -tags=loadtest ./...

# æ¸…ç†æµ‹è¯•æ–‡ä»¶
test-clean:
	rm -f coverage.out coverage.html
```

### 8.9.2 æµ‹è¯•è„šæœ¬
```bash
#!/bin/bash
# scripts/run-tests.sh

set -e

echo "ğŸ” è¿è¡Œä»£ç æ£€æŸ¥..."
golangci-lint run

echo "ğŸ§ª è¿è¡Œå•å…ƒæµ‹è¯•..."
go test -v -race -tags=unit ./...

echo "ğŸ”— è¿è¡Œé›†æˆæµ‹è¯•..."
go test -v -race -tags=integration ./...

echo "ğŸ“Š ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š..."
go test -v -race -coverprofile=coverage.out ./...
go tool cover -func=coverage.out
go tool cover -html=coverage.out -o coverage.html

echo "âš¡ è¿è¡ŒåŸºå‡†æµ‹è¯•..."
go test -v -bench=. -benchmem ./...

echo "âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡!"
```

### 8.9.3 æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ
```go
package testreport

import (
    "encoding/json"
    "os"
    "time"
)

// TestReport æµ‹è¯•æŠ¥å‘Š
type TestReport struct {
    Timestamp   time.Time     `json:"timestamp"`
    TotalTests  int           `json:"total_tests"`
    PassedTests int           `json:"passed_tests"`
    FailedTests int           `json:"failed_tests"`
    Coverage    float64       `json:"coverage"`
    Duration    time.Duration `json:"duration"`
    Errors      []string      `json:"errors,omitempty"`
}

// GenerateReport ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
func GenerateReport(report *TestReport, filename string) error {
    file, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    encoder := json.NewEncoder(file)
    encoder.SetIndent("", "  ")
    return encoder.Encode(report)
}
```